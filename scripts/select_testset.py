"""
Select lines from tagged files to get an entity type distribution
in the test set that is representative for the complete tagged set.
"""

__author__ = 'Pablo Ruiz'
__date__ = '13/09/17'
__email__ = 'pabloruizfabo@gmail.com'


import codecs
import os
import re
import sys

# script path
import inspect
here = os.path.dirname(os.path.abspath(
    inspect.getfile(inspect.currentframe())))
sys.path.append(here)

import config as cf


# io
try:
    bdir = sys.argv[1]
except IndexError:
    bdir = cf.bdir

odir = os.path.join(os.path.split(bdir)[0], "selected" + os.sep +
                    cf.batch_name + os.sep + "selected_testset")


# process

def rearrange_targets(fnames):
    """
    Produce filename-to-genre and filename-to-target dicts based on
    the genre to filename to target dict

    @param fnames: dict mapping genres to filenames to required number of lines
    per filename
    @return: (dict mapping filenames to required lines, dict mapping filenames
    to their genre)
    @rtype: tuple
    """
    fns_only = {}  # fn to count
    fn2genre = {}  #
    for genre in cf.filenames:
        fns_only.update(fnames[genre])
        for fn in fnames[genre]:
            fn2genre[fn] = genre
    return fns_only, fn2genre


def select_lines(fns_only, fn2genre):
    """
    Using 'sed', select lines from files based on L{cf.filenames} and the dicts
    generated by L{rearrange_targets}.
    Find number of matches for a tag overall and per genre

    @param fns_only: dict with nbr of lines required per file
    to extract approximate number of entities required of each type
    @param fn2genre: dict that maps filenames to their genre, used to
    compute per-genre counts
    @return: tuple (tag counts overall, tag counts per genre)
    @rtype: tuple
    """
    tagdi = {tag: 0 for tag in cf.tags}
    genre2tag = {}
    for fn in fns_only:
        ffn = os.path.join(bdir, fn)
        ofn = os.path.join(odir, fn)
        # run sed to select the first lines up to target
        cmd = "sed -n 1,{}p {} > {}".format(fns_only[fn], ffn, ofn)
        print cmd
        os.system(cmd)
        genre2tag.setdefault(fn2genre[fn], {})
        txt = codecs.open(ofn, "r", "utf8").read()
        for tag in cf.tags:
            tagre = re.compile(r"</{}".format(tag))
            matches = re.findall(tagre, txt)
            # print matches[0:10]
            tagdi[tag] += len(matches)
            genre2tag[fn2genre[fn]].setdefault(tag, 0)
            genre2tag[fn2genre[fn]][tag] += len(matches)
    return tagdi, genre2tag


def main():
    """Run"""
    for mydir in (odir, cf.odir_merged_loc.format(odir)):
        if not os.path.exists(mydir):
            os.makedirs(mydir)
    fns_only, fn2genre = rearrange_targets(cf.filenames)
    tagdi, genre2tag = select_lines(fns_only, fn2genre)
    for mytag in cf.tags:
        print "{}\t{}".format(mytag, tagdi[mytag])
    print "Total entities", sum(tagdi.values())
    from pprint import pprint
    pprint(genre2tag)
    # neutralize placeName vs geogName
    copy_cmd = "cp {}/* {}".format(odir, cf.odir_merged_loc.format(odir))
    print "Copying: {}".format(copy_cmd)
    os.system(copy_cmd)
    cmd = "{} {}".format(cf.locmerger, cf.odir_merged_loc.format(odir))
    print "\nNeutralizing geogName and placeName"
    print "In: {}".format(odir)
    print "Out: {}".format(cf.odir_merged_loc.format(odir))
    print "Command: {}".format(cmd)
    os.system(cmd)


if __name__ == "__main__":
    main()
